// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";

interface ISquadManager {
    function getUserProfile(address user) external view returns (
        string memory squadName,
        uint256 totalScore,
        uint256 joinDate,
        uint256 submissionsCount,
        uint256 lastSubmissionTime,
        uint256 verificationCount
    );
    
    function addPoints(address user, uint256 points) external;
}

contract DailyChallenge is AccessControl {
    address public immutable squadManagerAddress;
    
    struct Challenge {
        uint256 day;
        uint256 challengeType;
        string title;
        string description;
        string theme;
        uint256 bonusPoints;
    }
    
    struct DailySubmission {
        address user;
        string ipfsHash;      // Photo on IPFS
        string quote;          // Quote stored on-chain
        uint256 timestamp;
        bool verified;
        uint256 verifierCount;
        mapping(address => bool) hasVerified;
    }
    
    Challenge public currentChallenge;
    
    // Day => user => submission
    mapping(uint256 => mapping(address => DailySubmission)) private dailySubmissions;
    // Day => array of submitters
    mapping(uint256 => address[]) private dailyParticipants;
    mapping(uint256 => bool) public dayGenerated;
    
    // Real challenge templates
    string[] private titles;
    string[] private descriptions;
    string[] private themes;
    
    // Events
    event ChallengeAutoGenerated(uint256 indexed day, uint256 indexed challengeType, string title, uint256 bonusPoints);
    event DailySubmissionAdded(uint256 indexed day, address indexed user, string ipfsHash, string quote);
    event DailySubmissionVerified(uint256 indexed day, address indexed submitter, address indexed verifier, uint256 verifierCount);
    event PointsAwarded(uint256 indexed day, address indexed user, uint256 points);

    constructor(address _squadManagerAddress) {
        require(_squadManagerAddress != address(0), "Invalid SquadManager address");
        squadManagerAddress = _squadManagerAddress;
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        
        // Initialize with real challenge templates
        _initializeTemplates();
    }
    
    function _initializeTemplates() private {
        titles = [
            "Favorite Book Character",
            "Best Plot Twist",
            "Most Memorable Quote",
            "Book That Changed You",
            "Underrated Gem",
            "Childhood Favorite",
            "Book Hangover",
            "Favorite Author",
            "Beautiful Cover",
            "Book Setting You'd Visit",
            "Villain You Love to Hate",
            "Most Emotional Scene",
            "Book That Made You Cry",
            "Book That Made You Laugh",
            "Best Opening Line",
            "Most Satisfying Ending",
            "Book You Reread Most",
            "Book You Couldn't Finish",
            "Guilty Pleasure Read",
            "Book With Best Magic System",
            "Most Relatable Character",
            "Best Friendship in Literature",
            "Most Epic Battle Scene",
            "Best Romance",
            "Most Unique Writing Style",
            "Book That Kept You Up All Night",
            "Best Book to Movie Adaptation",
            "Most Overrated Book",
            "Hidden Gem of 2024",
            "Best Series Finale"
        ];
        
        descriptions = [
            "Describe your favorite book character and why they resonate with you",
            "Share a plot twist that caught you completely off guard",
            "Post a quote that lives rent-free in your head",
            "A book that changed your perspective on life",
            "Recommend an underrated book more people should read",
            "A book from your childhood that you still love",
            "A book that left you unable to read anything else for days",
            "Tell us about an author whose work you adore",
            "Share a book cover that you think is beautiful",
            "Which fictional place would you most want to visit?",
            "Describe a villain you couldn't help but love",
            "Share a scene that emotionally destroyed you",
            "A book that made you ugly cry",
            "A book that had you laughing out loud",
            "Share the best opening line you've ever read",
            "An ending that left you completely satisfied",
            "A book you've read more than 3 times",
            "A book you couldn't finish (no judgment!)",
            "What's your guilty pleasure read?",
            "A book with the most creative magic system",
            "Which character do you relate to most and why?",
            "Share your favorite literary friendship",
            "Describe an epic battle that gave you chills",
            "Tell us about your favorite book romance",
            "What book has the most unique writing style?",
            "A book that kept you reading until sunrise",
            "Which book adaptation did the book justice?",
            "A popular book you think is overrated",
            "Recommend a hidden gem you discovered this year",
            "Which series had the perfect ending?"
        ];
        
        themes = [
            "Characters",
            "Plot Twists",
            "Quotes", 
            "Impact",
            "Hidden Gems",
            "Nostalgia",
            "Book Hangover",
            "Authors",
            "Cover Art",
            "World Building",
            "Villains",
            "Emotional",
            "Sad Reads",
            "Funny Reads",
            "Writing Style",
            "Endings",
            "Re-reading",
            "Confessions",
            "Guilty Pleasures",
            "Magic Systems",
            "Relatable",
            "Friendship",
            "Action",
            "Romance",
            "Style",
            "Sleepless",
            "Adaptations",
            "Hot Takes",
            "Discovery",
            "Series"
        ];
    }
    
    function generateDailyChallenge() external {
        uint256 today = block.timestamp / 1 days;
        
        require(!dayGenerated[today], "Today's challenge already exists");
        
        // Use on-chain randomness
        uint256 randomSeed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.prevrandao,
            block.number,
            msg.sender
        )));
        
        uint256 index = randomSeed % titles.length;
        uint256 points = 20 + (randomSeed % 31); // 20-50 points
        
        currentChallenge = Challenge({
            day: today,
            challengeType: index % 10,
            title: titles[index],
            description: descriptions[index],
            theme: themes[index],
            bonusPoints: points
        });
        
        dayGenerated[today] = true;
        
        emit ChallengeAutoGenerated(today, index, titles[index], points);
    }
    
    // Submit daily challenge response with photo (ipfsHash) and quote
    function submitDailyChallenge(string calldata ipfsHash, string calldata quote) external {
        uint256 today = block.timestamp / 1 days;
        
        require(dayGenerated[today], "No active challenge for today");
        require(bytes(ipfsHash).length > 0, "IPFS hash cannot be empty");
        require(bytes(quote).length > 0, "Quote cannot be empty");
        require(currentChallenge.day == today, "Challenge mismatch");
        
        // Check if user is in a squad
        ISquadManager squadManager = ISquadManager(squadManagerAddress);
        (string memory squadName, , , , , ) = squadManager.getUserProfile(msg.sender);
        require(bytes(squadName).length > 0, "Must be in a squad");
        
        // Check if already submitted
        require(dailySubmissions[today][msg.sender].timestamp == 0, "Already submitted today");
        
        DailySubmission storage submission = dailySubmissions[today][msg.sender];
        submission.user = msg.sender;
        submission.ipfsHash = ipfsHash;   // Store photo hash
        submission.quote = quote;          // Store quote
        submission.timestamp = block.timestamp;
        submission.verified = false;
        submission.verifierCount = 0;
        
        dailyParticipants[today].push(msg.sender);
        
        emit DailySubmissionAdded(today, msg.sender, ipfsHash, quote);
    }
    
    // Verify a daily challenge submission - 1 verification for demo
    function verifyDailySubmission(address submitter) external {
        uint256 today = block.timestamp / 1 days;
        
        require(dayGenerated[today], "No active challenge for today");
        require(submitter != msg.sender, "Cannot verify yourself");
        
        DailySubmission storage submission = dailySubmissions[today][submitter];
        require(submission.timestamp > 0, "Submission doesn't exist");
        require(!submission.verified, "Already verified");
        require(!submission.hasVerified[msg.sender], "Already verified this submission");
        
        // Check if verifier is in a squad
        ISquadManager squadManager = ISquadManager(squadManagerAddress);
        (string memory verifierSquad, , , , , ) = squadManager.getUserProfile(msg.sender);
        require(bytes(verifierSquad).length > 0, "Must be in a squad");
        
        submission.verifierCount++;
        submission.hasVerified[msg.sender] = true;
        
        emit DailySubmissionVerified(today, submitter, msg.sender, submission.verifierCount);
        
        // Need 1 verification for demo
        if (submission.verifierCount >= 1 && !submission.verified) {
            submission.verified = true;
            
            // Award points through SquadManager
            squadManager.addPoints(submitter, currentChallenge.bonusPoints);
            
            emit PointsAwarded(today, submitter, currentChallenge.bonusPoints);
        }
    }
    
    // View functions
    function getCurrentChallenge() external view returns (Challenge memory) {
        return currentChallenge;
    }
    
    function getDailyParticipants(uint256 day) external view returns (address[] memory) {
        return dailyParticipants[day];
    }
    
    function getDailySubmission(uint256 day, address user) external view returns (
        address submitter,
        string memory ipfsHash,
        string memory quote,
        uint256 timestamp,
        bool verified,
        uint256 verifierCount
    ) {
        DailySubmission storage submission = dailySubmissions[day][user];
        return (
            submission.user,
            submission.ipfsHash,
            submission.quote,
            submission.timestamp,
            submission.verified,
            submission.verifierCount
        );
    }
    
    function hasSubmittedToday(address user) external view returns (bool) {
        uint256 today = block.timestamp / 1 days;
        return dailySubmissions[today][user].timestamp > 0;
    }
    
    function getVerificationStatus(uint256 day, address user) external view returns (
        bool verified,
        uint256 verifierCount
    ) {
        DailySubmission storage submission = dailySubmissions[day][user];
        return (submission.verified, submission.verifierCount);
    }
}