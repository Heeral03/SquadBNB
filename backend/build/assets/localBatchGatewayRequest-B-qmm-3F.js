import{ch as l,bP as p,d9 as w,p as y,bi as A,bJ as g,i as b,g as F,bs as E,be as N,n as h,o as P,a2 as R,da as f,db as I}from"./index-BDcKlTkx.js";function q(n){const{abi:s,data:e}=n,a=l(e,0,4),t=s.find(o=>o.type==="function"&&a===p(w(o)));if(!t)throw new y(a,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:t.name,args:"inputs"in t&&t.inputs&&t.inputs.length>0?A(t.inputs,l(e,4)):void 0}}const u="/docs/contract/encodeErrorResult";function m(n){const{abi:s,errorName:e,args:a}=n;let t=s[0];if(e){const c=g({abi:s,args:a,name:e});if(!c)throw new b(e,{docsPath:u});t=c}if(t.type!=="error")throw new b(void 0,{docsPath:u});const o=w(t),r=p(o);let i="0x";if(a&&a.length>0){if(!t.inputs)throw new F(t.name,{docsPath:u});i=E(t.inputs,a)}return N([r,i])}const d="/docs/contract/encodeFunctionResult";function x(n){const{abi:s,functionName:e,result:a}=n;let t=s[0];if(e){const r=g({abi:s,name:e});if(!r)throw new h(e,{docsPath:d});t=r}if(t.type!=="function")throw new h(void 0,{docsPath:d});if(!t.outputs)throw new P(t.name,{docsPath:d});const o=(()=>{if(t.outputs.length===0)return[];if(t.outputs.length===1)return[a];if(Array.isArray(a))return a;throw new R(a)})();return E(t.outputs,o)}const G="x-batch-gateway:true";async function H(n){const{data:s,ccipRequest:e}=n,{args:[a]}=q({abi:f,data:s}),t=[],o=[];return await Promise.all(a.map(async(r,i)=>{try{o[i]=r.urls.includes(G)?await H({data:r.data,ccipRequest:e}):await e(r),t[i]=!1}catch(c){t[i]=!0,o[i]=M(c)}})),x({abi:f,functionName:"query",result:[t,o]})}function M(n){return n.name==="HttpRequestError"&&n.status?m({abi:f,errorName:"HttpError",args:[n.status,n.shortMessage]}):m({abi:[I],errorName:"Error",args:["shortMessage"in n?n.shortMessage:n.message]})}export{x as a,H as b,q as d,m as e,G as l};
