const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-D6OT8ETN.js","assets/index-BDcKlTkx.js","assets/index-DQ3P1g1z.css","assets/parseSignature-DQ5hEUpX.js","assets/localBatchGatewayRequest-B-qmm-3F.js","assets/secp256k1-DsyUAzfK.js","assets/hashTypedData-DqbblKay.js","assets/index-Dx4FlqwZ.js","assets/index-My90LZL7.js","assets/index-BQkLIiM2.js","assets/index-CcJJopBA.js"])))=>i.map(i=>d[i]);
import{dD as Z,dE as O,bh as V,bK as N,aF as z,dF as v,c3 as j,bI as T,dG as G,aY as D,az as b,b_ as F,cl as B,dH as A,cw as S,bV as J,cx as x,ax as k,dI as L}from"./index-BDcKlTkx.js";import{dJ as re}from"./index-BDcKlTkx.js";function H(w,{body:g,onError:a,onResponse:M}){return w.request({body:g,onError:a,onResponse:M}),w}async function K(w,{body:g,timeout:a=1e4}){return w.requestAsync({body:g,timeout:a})}const E={http(w,g){return Z(w).request(g)},webSocket:H,webSocketAsync:K};U.type="mock";function U(w){const g=new Map,a=w.features??{defaultConnected:!1};let M=a.defaultConnected,l;return O(d=>({id:"mock",name:"Mock Connector",type:U.type,async setup(){l=d.chains[0].id},async connect({chainId:e,withCapabilities:i}={}){if(a.connectError)throw typeof a.connectError=="boolean"?new D(new Error("Failed to connect.")):a.connectError;const r=await(await this.getProvider()).request({method:"eth_requestAccounts"});let t=await this.getChainId();return e&&t!==e&&(t=(await this.switchChain({chainId:e})).id),M=!0,{accounts:i?r.map(n=>({address:N(n),capabilities:{foo:{bar:n}}})):r.map(n=>N(n)),chainId:t}},async disconnect(){M=!1},async getAccounts(){if(!M)throw new G;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>N(c))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return T(i,"number")},async isAuthorized(){return!a.reconnect||!M?!1:!!(await this.getAccounts()).length},async switchChain({chainId:e}){const i=await this.getProvider(),c=d.chains.find(r=>r.id===e);if(!c)throw new z(new v);return await i.request({method:"wallet_switchEthereumChain",params:[{chainId:j(e)}]}),c},onAccountsChanged(e){e.length===0?this.onDisconnect():d.emitter.emit("change",{accounts:e.map(i=>N(i))})},onChainChanged(e){const i=Number(e);d.emitter.emit("change",{chainId:i})},async onDisconnect(e){d.emitter.emit("disconnect"),M=!1},async getProvider({chainId:e}={}){const c=(d.chains.find(t=>t.id===e)??d.chains[0]).rpcUrls.default.http[0];return V({request:async({method:t,params:n})=>{if(t==="eth_chainId")return j(l);if(t==="eth_accounts"||t==="eth_requestAccounts")return w.accounts;if(t==="eth_signTypedData_v4"&&a.signTypedDataError)throw typeof a.signTypedDataError=="boolean"?new D(new Error("Failed to sign typed data.")):a.signTypedDataError;if(t==="wallet_switchEthereumChain"){if(a.switchChainError)throw typeof a.switchChainError=="boolean"?new D(new Error("Failed to switch chain.")):a.switchChainError;l=T(n[0].chainId,"number"),this.onChainChanged(l.toString());return}if(t==="wallet_watchAsset"){if(a.watchAssetError)throw typeof a.watchAssetError=="boolean"?new D(new Error("Failed to switch chain.")):a.watchAssetError;return M}if(t==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:n[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:n[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"}}};if(t==="wallet_sendCalls"){const u=[],h=n[0].calls,y=n[0].from;for(const I of h){const{result:C,error:m}=await E.http(c,{body:{method:"eth_sendTransaction",params:[{...I,...typeof y<"u"?{from:y}:{}}]}});if(m)throw new b({body:{method:t,params:n},error:m,url:c});u.push(C)}const f=F(B(JSON.stringify(h)));return g.set(f,u),{id:f}}if(t==="wallet_getCallsStatus"){const u=g.get(n[0]);if(!u)return{atomic:!1,chainId:"0x1",id:n[0],status:100,receipts:[],version:"2.0.0"};const y=(await Promise.all(u.map(async f=>{const{result:I,error:C}=await E.http(c,{body:{method:"eth_getTransactionReceipt",params:[f],id:0}});if(C)throw new b({body:{method:t,params:n},error:C,url:c});return I?{blockHash:I.blockHash,blockNumber:I.blockNumber,gasUsed:I.gasUsed,logs:I.logs,status:I.status,transactionHash:I.transactionHash}:null}))).filter(f=>f!==null);return y.length===0?{atomic:!1,chainId:"0x1",id:n[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:n[0],status:200,receipts:y,version:"2.0.0"}}if(t==="wallet_showCallsStatus")return;if(t==="personal_sign"){if(a.signMessageError)throw typeof a.signMessageError=="boolean"?new D(new Error("Failed to sign message.")):a.signMessageError;t="eth_sign",n=[n[1],n[0]]}const s={method:t,params:n},{error:o,result:p}=await E.http(c,{body:s});if(o)throw new b({body:s,error:o,url:c});return p}})({retryCount:0})}}))}function _(w){const{chain:g}=w,a=g.rpcUrls.default.http[0];if(!w.transports)return[a];const M=w.transports?.[g.id]?.({chain:g});return(M?.value?.transports||[M]).map(({value:d})=>d?.url||a)}function $(w={}){let g,a,M,l;return O(d=>({id:"baseAccount",name:"Base Account",rdns:"app.base.account",type:"baseAccount",async connect({chainId:e,withCapabilities:i,...c}={}){try{const r=await this.getProvider(),t=e??d.chains[0]?.id;if(!t)throw new v;let{accounts:n,currentChainId:s}=await(async()=>{if(c.isReconnecting)return{accounts:(await r.request({method:"eth_accounts",params:[]})).map(h=>({address:N(h)})),currentChainId:await this.getChainId()};const o=await r.request({method:"wallet_connect",params:[{capabilities:"capabilities"in c&&c.capabilities?c.capabilities:{},chainIds:[j(t),...d.chains.filter(h=>h.id!==t).map(h=>j(h.id))]}]});return{accounts:(await r.request({method:"eth_accounts"})).map(h=>o.accounts.find(y=>y.address===h)??{address:h}).map(h=>({address:N(h.address),capabilities:h.capabilities??{}})),currentChainId:Number(o.chainIds[0])}})();return a||(a=this.onAccountsChanged.bind(this),r.on("accountsChanged",a)),M||(M=this.onChainChanged.bind(this),r.on("chainChanged",M)),l||(l=this.onDisconnect.bind(this),r.on("disconnect",l)),e&&s!==e&&(s=(await this.switchChain({chainId:e}).catch(p=>{if(p.code===D.code)throw p;return{id:s}}))?.id??s),{accounts:i?n:n.map(o=>o.address),chainId:s}}catch(r){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(r.message)?new D(r):r}},async disconnect(){const e=await this.getProvider();a&&(e.removeListener("accountsChanged",a),a=void 0),M&&(e.removeListener("chainChanged",M),M=void 0),l&&(e.removeListener("disconnect",l),l=void 0),e.disconnect()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(i=>N(i))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return Number(i)},async getProvider(){if(!g){const e=typeof w.preference=="string"?{options:w.preference}:{...w.preference,options:w.preference?.options??"all"},{createBaseAccountSDK:i}=await(()=>{try{return A(()=>import("./index-D6OT8ETN.js"),__vite__mapDeps([0,1,2,3,4,5,6]))}catch{throw new Error('dependency "@base-org/account" not found')}})();g=i({...w,appChainIds:d.chains.map(r=>r.id),preference:e}).getProvider()}return g},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:i}){const c=d.chains.find(t=>t.id===i);if(!c)throw new z(new v);const r=await this.getProvider();try{return await r.request({method:"wallet_switchEthereumChain",params:[{chainId:j(c.id)}]}),c}catch(t){if(t.code===4902)try{let n;e?.blockExplorerUrls?n=e.blockExplorerUrls:n=c.blockExplorers?.default.url?[c.blockExplorers?.default.url]:[];let s;e?.rpcUrls?.length?s=e.rpcUrls:s=[c.rpcUrls.default?.http[0]??""];const o={blockExplorerUrls:n,chainId:j(i),chainName:e?.chainName??c.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??c.nativeCurrency,rpcUrls:s};return await r.request({method:"wallet_addEthereumChain",params:[o]}),c}catch(n){throw new D(n)}throw new z(t)}},onAccountsChanged(e){e.length===0?this.onDisconnect():d.emitter.emit("change",{accounts:e.map(i=>N(i))})},onChainChanged(e){const i=Number(e);d.emitter.emit("change",{chainId:i})},async onDisconnect(e){d.emitter.emit("disconnect");const i=await this.getProvider();a&&(i.removeListener("accountsChanged",a),a=void 0),M&&(i.removeListener("chainChanged",M),M=void 0),l&&(i.removeListener("disconnect",l),l=void 0)}}))}P.type="coinbaseWallet";function P(w={}){let g,a,M,l;return O(d=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:P.type,async connect({chainId:e,withCapabilities:i,...c}={}){try{const r=await this.getProvider(),t=(await r.request({method:"eth_requestAccounts",params:"instantOnboarding"in c&&c.instantOnboarding?[{onboarding:"instant"}]:[]})).map(s=>N(s));a||(a=this.onAccountsChanged.bind(this),r.on("accountsChanged",a)),M||(M=this.onChainChanged.bind(this),r.on("chainChanged",M)),l||(l=this.onDisconnect.bind(this),r.on("disconnect",l));let n=await this.getChainId();return e&&n!==e&&(n=(await this.switchChain({chainId:e}).catch(o=>{if(o.code===D.code)throw o;return{id:n}}))?.id??n),{accounts:i?t.map(s=>({address:s,capabilities:{}})):t,chainId:n}}catch(r){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(r.message)?new D(r):r}},async disconnect(){const e=await this.getProvider();a&&(e.removeListener("accountsChanged",a),a=void 0),M&&(e.removeListener("chainChanged",M),M=void 0),l&&(e.removeListener("disconnect",l),l=void 0),e.disconnect(),e.close?.()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(i=>N(i))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return Number(i)},async getProvider(){if(!g){const{createCoinbaseWalletSDK:e}=await(()=>{try{return A(()=>import("./connectors_false-eecCuxGE.js"),[])}catch{throw new Error('dependency "@coinbase/wallet-sdk" not found')}})();g=e({...w,appChainIds:d.chains.map(c=>c.id),preference:{options:"all",...w.preference??{}}}).getProvider()}return g},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:i}){const c=d.chains.find(t=>t.id===i);if(!c)throw new z(new v);const r=await this.getProvider();try{return await r.request({method:"wallet_switchEthereumChain",params:[{chainId:j(c.id)}]}),c}catch(t){if(t.code===4902)try{let n;e?.blockExplorerUrls?n=e.blockExplorerUrls:n=c.blockExplorers?.default.url?[c.blockExplorers?.default.url]:[];let s;e?.rpcUrls?.length?s=e.rpcUrls:s=[c.rpcUrls.default?.http[0]??""];const o={blockExplorerUrls:n,chainId:j(i),chainName:e?.chainName??c.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??c.nativeCurrency,rpcUrls:s};return await r.request({method:"wallet_addEthereumChain",params:[o]}),c}catch(n){throw new D(n)}throw new z(t)}},onAccountsChanged(e){e.length===0?this.onDisconnect():d.emitter.emit("change",{accounts:e.map(i=>N(i))})},onChainChanged(e){const i=Number(e);d.emitter.emit("change",{chainId:i})},async onDisconnect(e){d.emitter.emit("disconnect");const i=await this.getProvider();a&&(i.removeListener("accountsChanged",a),a=void 0),M&&(i.removeListener("chainChanged",M),M=void 0),l&&(i.removeListener("disconnect",l),l=void 0)}}))}Y.type="gemini";function Y(w={}){let g,a,M,l;return O(d=>({id:"gemini",name:"Gemini Wallet",type:Y.type,icon:"https://keys.gemini.com/images/gemini-wallet-logo.svg",async connect({chainId:e,withCapabilities:i}={}){try{const c=await this.getProvider(),r=await c.request({method:"eth_requestAccounts"});a||(a=this.onAccountsChanged.bind(this),c.on("accountsChanged",a)),M||(M=this.onChainChanged.bind(this),c.on("chainChanged",M)),l||(l=this.onDisconnect.bind(this),c.on("disconnect",l));let t=await this.getChainId();return e&&t!==e&&(t=(await this.switchChain({chainId:e}).catch(s=>{if(s.code===D.code)throw s;return{id:t}}))?.id??t),{accounts:i?r.map(n=>({address:n,capabilities:{}})):r,chainId:t}}catch(c){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(c.message)?new D(c):c}},async disconnect(){const e=await this.getProvider();a&&(e.removeListener("accountsChanged",a),a=void 0),M&&(e.removeListener("chainChanged",M),M=void 0),l&&(e.removeListener("disconnect",l),l=void 0),await e.disconnect()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>N(c))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return Number(i)},async getProvider(){if(!g){const{GeminiWalletProvider:e}=await(()=>{try{return A(()=>import("./connectors_false-CcmhZ4C3.js"),[])}catch{throw new Error('dependency "@gemini-wallet/core" not found')}})();g=new e({appMetadata:w.appMetadata??{},chain:{id:d.chains[0]?.id??1,rpcUrl:d.chains[0]?.rpcUrls?.default?.http[0]}})}return g},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({chainId:e}){const i=d.chains.find(r=>r.id===e);if(!i)throw new z(new v);const c=await this.getProvider();try{return await c.request({method:"wallet_switchEthereumChain",params:[{chainId:j(e)}]}),i}catch(r){throw new z(r)}},onAccountsChanged(e){e.length===0?this.onDisconnect():d.emitter.emit("change",{accounts:e.map(i=>N(i))})},onChainChanged(e){const i=Number(e);d.emitter.emit("change",{chainId:i})},async onDisconnect(){d.emitter.emit("disconnect");const e=await this.getProvider();a&&(e.removeListener("accountsChanged",a),a=void 0),M&&(e.removeListener("chainChanged",M),M=void 0),l&&(e.removeListener("disconnect",l),l=void 0)}}))}Q.type="metaMask";function Q(w={}){let g,a,M,l,d,e,i,c;return O(r=>({id:"metaMaskSDK",name:"MetaMask",rdns:["io.metamask","io.metamask.mobile"],type:Q.type,async setup(){const t=await this.getProvider();t?.on&&(e||(e=this.onConnect.bind(this),t.on("connect",e)),l||(l=this.onAccountsChanged.bind(this),t.on("accountsChanged",l)))},async connect({chainId:t,isReconnecting:n,withCapabilities:s}={}){const o=await this.getProvider();i||(i=this.onDisplayUri,o.on("display_uri",i));let p=[];n&&(p=await this.getAccounts().catch(()=>[]));try{let u,h;p?.length||(w.connectAndSign||w.connectWith?(w.connectAndSign?u=await g.connectAndSign({msg:w.connectAndSign}):w.connectWith&&(h=await g.connectWith({method:w.connectWith.method,params:w.connectWith.params})),p=await this.getAccounts()):p=(await g.connect()).map(I=>N(I)));let y=await this.getChainId();return t&&y!==t&&(y=(await this.switchChain({chainId:t}).catch(I=>{if(I.code===D.code)throw I;return{id:y}}))?.id??y),i&&(o.removeListener("display_uri",i),i=void 0),u?o.emit("connectAndSign",{accounts:p,chainId:y,signResponse:u}):h&&o.emit("connectWith",{accounts:p,chainId:y,connectWithResponse:h}),e&&(o.removeListener("connect",e),e=void 0),l||(l=this.onAccountsChanged.bind(this),o.on("accountsChanged",l)),d||(d=this.onChainChanged.bind(this),o.on("chainChanged",d)),c||(c=this.onDisconnect.bind(this),o.on("disconnect",c)),{accounts:s?p.map(f=>({address:f,capabilities:{}})):p,chainId:y}}catch(u){const h=u;throw h.code===D.code?new D(h):h.code===k.code?new k(h):h}},async disconnect(){const t=await this.getProvider();d&&(t.removeListener("chainChanged",d),d=void 0),c&&(t.removeListener("disconnect",c),c=void 0),e||(e=this.onConnect.bind(this),t.on("connect",e)),await g.terminate()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(s=>N(s))},async getChainId(){const t=await this.getProvider(),n=t.getChainId()||await t?.request({method:"eth_chainId"});return Number(n)},async getProvider(){async function t(){const n=await(async()=>{const{default:u}=await(()=>{try{return A(()=>import("./connectors_false-CBUJNXH8.js"),[])}catch{throw new Error('dependency "@metamask/sdk" not found')}})();return typeof u!="function"&&typeof u.default=="function"?u.default:u})(),s={};for(const u of r.chains)s[j(u.id)]=_({chain:u,transports:r.transports})?.[0];g=new n({...w,_source:"wagmi",forceDeleteProvider:!1,forceInjectProvider:!1,injectProvider:!1,readonlyRPCMap:s,dappMetadata:{...w.dappMetadata,name:w.dappMetadata?.name?w.dappMetadata?.name:"wagmi",url:w.dappMetadata?.url?w.dappMetadata?.url:typeof window<"u"?window.location.origin:"https://wagmi.sh"},useDeeplink:!0});const o=await g.init(),p=o?.activeProvider?o.activeProvider:g.getProvider();if(!p)throw new L;return p}return a||(M||(M=t()),a=await M),a},async isAuthorized(){try{return!!(await S(()=>x(()=>this.getAccounts(),{timeout:200}),{delay:201,retryCount:3})).length}catch{return!1}},async switchChain({addEthereumChainParameter:t,chainId:n}){const s=await this.getProvider(),o=r.chains.find(h=>h.id===n);if(!o)throw new z(new v);try{return await s.request({method:"wallet_switchEthereumChain",params:[{chainId:j(n)}]}),await p(),await u(n),o}catch(h){const y=h;if(y.code===D.code)throw new D(y);if(y.code===4902||y?.data?.originalError?.code===4902)try{return await s.request({method:"wallet_addEthereumChain",params:[{blockExplorerUrls:(()=>{const{default:f,...I}=o.blockExplorers??{};if(t?.blockExplorerUrls)return t.blockExplorerUrls;if(f)return[f.url,...Object.values(I).map(C=>C.url)]})(),chainId:j(n),chainName:t?.chainName??o.name,iconUrls:t?.iconUrls,nativeCurrency:t?.nativeCurrency??o.nativeCurrency,rpcUrls:t?.rpcUrls?.length?t.rpcUrls:[o.rpcUrls.default?.http[0]??""]}]}),await p(),await u(n),o}catch(f){const I=f;throw I.code===D.code?new D(I):new z(I)}throw new z(y)}async function p(){await S(async()=>{const h=J(await s.request({method:"eth_chainId"}));if(h!==n)throw new Error("User rejected switch after adding network.");return h},{delay:50,retryCount:20})}async function u(h){await new Promise(y=>{const f=(I=>{"chainId"in I&&I.chainId===h&&(r.emitter.off("change",f),y())});r.emitter.on("change",f),r.emitter.emit("change",{chainId:h})})}},async onAccountsChanged(t){if(t.length===0)if(g.isExtensionActive())this.onDisconnect();else return;else if(r.emitter.listenerCount("connect")){const n=(await this.getChainId()).toString();this.onConnect({chainId:n})}else r.emitter.emit("change",{accounts:t.map(n=>N(n))})},onChainChanged(t){const n=Number(t);r.emitter.emit("change",{chainId:n})},async onConnect(t){const n=await this.getAccounts();if(n.length===0)return;const s=Number(t.chainId);r.emitter.emit("connect",{accounts:n,chainId:s});const o=await this.getProvider();e&&(o.removeListener("connect",e),e=void 0),l||(l=this.onAccountsChanged.bind(this),o.on("accountsChanged",l)),d||(d=this.onChainChanged.bind(this),o.on("chainChanged",d)),c||(c=this.onDisconnect.bind(this),o.on("disconnect",c))},async onDisconnect(t){const n=await this.getProvider();t&&t.code===1013&&n&&(await this.getAccounts()).length||(r.emitter.emit("disconnect"),d&&(n.removeListener("chainChanged",d),d=void 0),c&&(n.removeListener("disconnect",c),c=void 0),e||(e=this.onConnect.bind(this),n.on("connect",e)))},onDisplayUri(t){r.emitter.emit("message",{type:"display_uri",data:t})}}))}function ee(w={}){return O(g=>{const a=g.chains??w.chains??[],M=g.transports?g.transports:w.transports;let l,d,e,i,c;return{async connect({chainId:r=a[0].id,...t}={}){const n="isReconnecting"in t&&t.isReconnecting||!1,s="withCapabilities"in t&&t.withCapabilities||!1;let o=[],p;n&&([o,p]=await Promise.all([this.getAccounts().catch(()=>[]),this.getChainId().catch(()=>{})]),r&&p!==r&&(p=(await this.switchChain({chainId:r}).catch(y=>{if(y.code===D.code)throw y;return{id:p}}))?.id??p));const u=await this.getProvider();try{if(!o?.length&&!n){const{RpcSchema:h}=await(()=>{try{return A(()=>import("./connectors_false-B0bBwmCt.js"),[])}catch{throw new Error('dependency "porto" not found')}})(),{z:y}=await(()=>{try{return A(()=>import("./connectors_false-BCrRTJi8.js"),[])}catch{throw new Error('dependency "porto/internal" not found')}})(),f=await u.request({method:"wallet_connect",params:[{..."capabilities"in t?{capabilities:y.encode(h.wallet_connect.Capabilities,t.capabilities??{})}:{},chainIds:[j(r),...a.filter(I=>I.id!==r).map(I=>j(I.id))]}]});o=f.accounts,p=Number(f.chainIds[0])}if(!p)throw new v;return i&&(u.removeListener("connect",i),i=void 0),d||(d=this.onAccountsChanged.bind(this),u.on("accountsChanged",d)),e||(e=this.onChainChanged.bind(this),u.on("chainChanged",e)),c||(c=this.onDisconnect.bind(this),u.on("disconnect",c)),{accounts:o.map(h=>typeof h=="object"?s?h:h.address:s?{address:h,capabilities:{}}:h),chainId:p}}catch(h){const y=h;throw y.code===D.code?new D(y):y}},async disconnect(){const r=await this.getProvider();e&&(r.removeListener("chainChanged",e),e=void 0),c&&(r.removeListener("disconnect",c),c=void 0),i||(i=this.onConnect.bind(this),r.on("connect",i)),await r.request({method:"wallet_disconnect"})},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(n=>N(n))},async getChainId(){const t=await(await this.getProvider()).request({method:"eth_chainId"});return Number(t)},async getPortoInstance(){return l??=(async()=>{const{Porto:r}=await(()=>{try{return A(()=>import("./connectors_false-B0bBwmCt.js"),[])}catch{throw new Error('dependency "porto" not found')}})();return r.create({...w,announceProvider:!1,chains:a,transports:M})})(),await l},async getProvider(){return(await this.getPortoInstance()).provider},icon:"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K",id:"xyz.ithaca.porto",async isAuthorized(){try{return!!(await S(()=>this.getAccounts())).length}catch{return!1}},name:"Porto",async onAccountsChanged(r){g.emitter.emit("change",{accounts:r.map(t=>N(t))})},onChainChanged(r){const t=Number(r);g.emitter.emit("change",{chainId:t})},async onConnect(r){const t=await this.getAccounts();if(t.length===0)return;const n=Number(r.chainId);g.emitter.emit("connect",{accounts:t,chainId:n});const s=await this.getProvider();s&&(i&&(s.removeListener("connect",i),i=void 0),d||(d=this.onAccountsChanged.bind(this),s.on("accountsChanged",d)),e||(e=this.onChainChanged.bind(this),s.on("chainChanged",e)),c||(c=this.onDisconnect.bind(this),s.on("disconnect",c)))},async onDisconnect(r){const t=await this.getProvider();g.emitter.emit("disconnect"),t&&(e&&(t.removeListener("chainChanged",e),e=void 0),c&&(t.removeListener("disconnect",c),c=void 0),i||(i=this.onConnect.bind(this),t.on("connect",i)))},async setup(){if(!i){const r=await this.getProvider();i=this.onConnect.bind(this),r.on("connect",i)}},async switchChain({chainId:r}){const t=a.find(s=>s.id===r);if(!t)throw new z(new v);return await(await this.getProvider()).request({method:"wallet_switchEthereumChain",params:[{chainId:j(r)}]}),t},type:"injected"}})}q.type="safe";function q(w={}){const{shimDisconnect:g=!1}=w;let a,M;return O(l=>({id:"safe",name:"Safe",type:q.type,async connect({withCapabilities:d}={}){const e=await this.getProvider();if(!e)throw new L;const i=await this.getAccounts(),c=await this.getChainId();return M||(M=this.onDisconnect.bind(this),e.on("disconnect",M)),g&&await l.storage?.removeItem("safe.disconnected"),{accounts:d?i.map(r=>({address:r,capabilities:{}})):i,chainId:c}},async disconnect(){const d=await this.getProvider();if(!d)throw new L;M&&(d.removeListener("disconnect",M),M=void 0),g&&await l.storage?.setItem("safe.disconnected",!0)},async getAccounts(){const d=await this.getProvider();if(!d)throw new L;return(await d.request({method:"eth_accounts"})).map(N)},async getProvider(){if(typeof window<"u"&&window?.parent!==window){if(!a){const{default:e}=await(()=>{try{return A(()=>import("./index-Dx4FlqwZ.js"),__vite__mapDeps([7,8,1,2,6]))}catch{throw new Error('dependency "@safe-global/safe-apps-sdk" not found')}})(),i=new e(w),c=await x(()=>i.safe.getInfo(),{timeout:w.unstable_getInfoTimeout??10});if(!c)throw new Error("Could not load Safe information");const r=await(async()=>{const t=await(()=>{try{return A(()=>import("./index-BQkLIiM2.js").then(n=>n.i),__vite__mapDeps([9,1,2,8]))}catch{throw new Error('dependency "@safe-global/safe-apps-provider" not found')}})();return typeof t.SafeAppProvider!="function"&&typeof t.default.SafeAppProvider=="function"?t.default.SafeAppProvider:t.SafeAppProvider})();a=new r(c,i)}return a}},async getChainId(){const d=await this.getProvider();if(!d)throw new L;return Number(d.chainId)},async isAuthorized(){try{return g&&await l.storage?.getItem("safe.disconnected")?!1:!!(await this.getAccounts()).length}catch{return!1}},onAccountsChanged(){},onChainChanged(){},onDisconnect(){l.emitter.emit("disconnect")}}))}const te="7.1.7";R.type="walletConnect";function R(w){const g=w.isNewChainsStale??!0;let a,M;const l="eip155";let d,e,i,c,r,t;return O(n=>({id:"walletConnect",name:"WalletConnect",type:R.type,async setup(){const s=await this.getProvider().catch(()=>null);s&&(i||(i=this.onConnect.bind(this),s.on("connect",i)),r||(r=this.onSessionDelete.bind(this),s.on("session_delete",r)))},async connect({chainId:s,withCapabilities:o,...p}={}){try{const u=await this.getProvider();if(!u)throw new L;c||(c=this.onDisplayUri,u.on("display_uri",c));let h=s;if(!h){const C=await n.storage?.getItem("state")??{};n.chains.some(W=>W.id===C.chainId)?h=C.chainId:h=n.chains[0]?.id}if(!h)throw new Error("No chains found on connector.");const y=await this.isChainsStale();if(u.session&&y&&await u.disconnect(),!u.session||y){const C=n.chains.filter(m=>m.id!==h).map(m=>m.id);await u.connect({optionalChains:[h,...C],..."pairingTopic"in p?{pairingTopic:p.pairingTopic}:{}}),this.setRequestedChainsIds(n.chains.map(m=>m.id))}const f=(await u.enable()).map(C=>N(C));let I=await this.getChainId();return s&&I!==s&&(I=(await this.switchChain({chainId:s}).catch(m=>{if(m.code===D.code&&m.cause?.message!=="Missing or invalid. request() method: wallet_addEthereumChain")throw m;return{id:I}}))?.id??I),c&&(u.removeListener("display_uri",c),c=void 0),i&&(u.removeListener("connect",i),i=void 0),d||(d=this.onAccountsChanged.bind(this),u.on("accountsChanged",d)),e||(e=this.onChainChanged.bind(this),u.on("chainChanged",e)),t||(t=this.onDisconnect.bind(this),u.on("disconnect",t)),r||(r=this.onSessionDelete.bind(this),u.on("session_delete",r)),{accounts:o?f.map(C=>({address:C,capabilities:{}})):f,chainId:I}}catch(u){throw/(user rejected|connection request reset)/i.test(u?.message)?new D(u):u}},async disconnect(){const s=await this.getProvider();try{await s?.disconnect()}catch(o){if(!/No matching key/i.test(o.message))throw o}finally{e&&(s?.removeListener("chainChanged",e),e=void 0),t&&(s?.removeListener("disconnect",t),t=void 0),i||(i=this.onConnect.bind(this),s?.on("connect",i)),d&&(s?.removeListener("accountsChanged",d),d=void 0),r&&(s?.removeListener("session_delete",r),r=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(o=>N(o))},async getProvider({chainId:s}={}){async function o(){const p=n.chains.map(h=>h.id);if(!p.length)return;const{EthereumProvider:u}=await(()=>{try{return A(()=>import("./index-CcJJopBA.js").then(h=>h.i),__vite__mapDeps([10,1,2]))}catch{throw new Error('dependency "@walletconnect/ethereum-provider" not found')}})();return await u.init({...w,disableProviderPing:!0,optionalChains:p,projectId:w.projectId,rpcMap:Object.fromEntries(n.chains.map(h=>{const[y]=_({chain:h,transports:n.transports});return[h.id,y]})),showQrModal:w.showQrModal??!0})}return a||(M||(M=o()),a=await M,a?.events.setMaxListeners(Number.POSITIVE_INFINITY)),s&&await this.switchChain?.({chainId:s}),a},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[s,o]=await Promise.all([this.getAccounts(),this.getProvider()]);return s.length?await this.isChainsStale()&&o.session?(await o.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:s,chainId:o}){const p=await this.getProvider();if(!p)throw new L;const u=n.chains.find(h=>h.id===o);if(!u)throw new z(new v);try{await Promise.all([new Promise(y=>{const f=({chainId:I})=>{I===o&&(n.emitter.off("change",f),y())};n.emitter.on("change",f)}),p.request({method:"wallet_switchEthereumChain",params:[{chainId:j(o)}]})]);const h=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...h,o]),u}catch(h){const y=h;if(/(user rejected)/i.test(y.message))throw new D(y);try{let f;s?.blockExplorerUrls?f=s.blockExplorerUrls:f=u.blockExplorers?.default.url?[u.blockExplorers?.default.url]:[];let I;s?.rpcUrls?.length?I=s.rpcUrls:I=[...u.rpcUrls.default.http];const C={blockExplorerUrls:f,chainId:j(o),chainName:s?.chainName??u.name,iconUrls:s?.iconUrls,nativeCurrency:s?.nativeCurrency??u.nativeCurrency,rpcUrls:I};await p.request({method:"wallet_addEthereumChain",params:[C]});const m=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...m,o]),u}catch(f){throw new D(f)}}},onAccountsChanged(s){s.length===0?this.onDisconnect():n.emitter.emit("change",{accounts:s.map(o=>N(o))})},onChainChanged(s){const o=Number(s);n.emitter.emit("change",{chainId:o})},async onConnect(s){const o=Number(s.chainId),p=await this.getAccounts();n.emitter.emit("connect",{accounts:p,chainId:o})},async onDisconnect(s){this.setRequestedChainsIds([]),n.emitter.emit("disconnect");const o=await this.getProvider();d&&(o.removeListener("accountsChanged",d),d=void 0),e&&(o.removeListener("chainChanged",e),e=void 0),t&&(o.removeListener("disconnect",t),t=void 0),r&&(o.removeListener("session_delete",r),r=void 0),i||(i=this.onConnect.bind(this),o.on("connect",i))},onDisplayUri(s){n.emitter.emit("message",{type:"display_uri",data:s})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){return a?a.session?.namespaces[l]?.accounts?.map(o=>Number.parseInt(o.split(":")[1]||"",10))??[]:[]},async getRequestedChainsIds(){return await n.storage?.getItem(this.requestedChainsStorageKey)??[]},async isChainsStale(){if(!g)return!1;const s=n.chains.map(u=>u.id),o=this.getNamespaceChainsIds();if(o.length&&!o.some(u=>s.includes(u)))return!1;const p=await this.getRequestedChainsIds();return!s.every(u=>p.includes(u))},async setRequestedChainsIds(s){await n.storage?.setItem(this.requestedChainsStorageKey,s)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}}))}export{$ as baseAccount,P as coinbaseWallet,Y as gemini,re as injected,Q as metaMask,U as mock,ee as porto,q as safe,te as version,R as walletConnect};
